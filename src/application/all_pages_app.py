import streamlit as st
import threading
import time
import pandas as pd
import json
import os

from main import update_store_data


def save_data(df, data_file="data/job.csv"):
    df.to_csv(data_file, sep=";", index=False, encoding="utf-8")

def get_color(score):
    r = int(255 - (score * 2.55))
    g = int(score * 2.55)
    return f"rgb({r},{g},0)"

def configuration_page():
    # üîÑ Chemin du fichier de config
    CONFIG_FILE = "config.json"
    DEFAULT_CONFIG_FILE = "config_default.json"

    # üß© Charger la configuration actuelle
    def load_config():
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        else:
            return {
                "keywords": [],
                "url": {
                    "wttj": "",
                    "apec": "",
                    "linkedin": ""
                },
                "launch_scrap": {
                    "wttj": False,
                    "apec": False,
                    "linkedin": False
                },
                "use_multithreading": False,
                "use_llm": False,
                "llm": {
                    "provider": "Local",
                    "gpt_api_key": "",
                    "mistral_api_key": "",
                    "generate_score": False,
                    "prompt_score": "",
                    "generate_custom_profile": False,
                    "prompt_custom_profile": "",
                    "cv": ""
                }
            }

    # üíæ Sauvegarder la configuration
    def save_config(config):
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2, ensure_ascii=False)

    # üîÅ R√©initialiser la configuration depuis config_default.json
    def reset_config():
        if os.path.exists(DEFAULT_CONFIG_FILE):
            with open(DEFAULT_CONFIG_FILE, "r", encoding="utf-8") as f:
                default_config = json.load(f)
            save_config(default_config)
            return True
        else:
            return False

    # üîß Interface utilisateur Streamlit
    st.title("üîß Configuration du Scraper")

    config = load_config()

    # üéØ Section mots-cl√©s
    st.header("üîë Mots-cl√©s")
    keywords = st.text_area("Entrez les mots-cl√©s (un par ligne)", "\n".join(config["keywords"]))
    config["keywords"] = [k.strip() for k in keywords.splitlines() if k.strip()]

    # üåê Section URLs
    st.header("üîó URLs des sites")
    config["url"]["wttj"] = st.text_input("WTTJ URL", config["url"]["wttj"])
    config["url"]["apec"] = st.text_input("APEC URL", config["url"]["apec"])
    config["url"]["linkedin"] = st.text_input("LinkedIn URL", config["url"]["linkedin"])

    # üöÄ Sites √† scraper
    st.header("üì° Lancer le scraping sur :")
    config["launch_scrap"]["wttj"] = st.checkbox("WTTJ", config["launch_scrap"]["wttj"])
    config["launch_scrap"]["apec"] = st.checkbox("APEC", config["launch_scrap"]["apec"])
    config["launch_scrap"]["linkedin"] = st.checkbox("LinkedIn", config["launch_scrap"]["linkedin"])

    # ‚öôÔ∏è Options g√©n√©rales
    st.header("‚öôÔ∏è Options g√©n√©rales")
    config["use_multithreading"] = st.checkbox(
        "Utiliser le multithreading (permet de scrapper plusieurs sites en m√™me temps mais demande plus de ressource)",
        config["use_multithreading"])
    config["use_llm"] = st.checkbox("Utiliser un LLM", config["use_llm"])

    # ü§ñ Configuration LLM
    if config["use_llm"]:
        st.subheader("üß† Param√®tres du LLM")

        # config["llm"]["local"] = st.checkbox("LLM local", config["llm"]["local"])
        # if not config["llm"]["local"]:
        #     config["llm"]["gpt_api_key"] = st.text_input("Cl√© API GPT (laissez vide si non utilis√©e)",
        #                                                  config["llm"]["gpt_api_key"])

        # Choix du LLM : local, ChatGPT ou Mistral
        config["llm"]["provider"] = st.radio(
            "Choisissez le fournisseur LLM :",
            ["Local", "ChatGPT", "Mistral"],
            index=["Local", "ChatGPT", "Mistral"].index(config["llm"].get("provider", "Local"))
        )

        # Gestion des champs selon le choix
        if config["llm"]["provider"] == "ChatGPT":
            config["llm"]["gpt_api_key"] = st.text_input(
                "Cl√© API GPT",
                config["llm"].get("gpt_api_key", "")
            )

        elif config["llm"]["provider"] == "Mistral":
            config["llm"]["mistral_api_key"] = st.text_input(
                "Cl√© API Mistral",
                config["llm"].get("mistral_api_key", "")
            )

        config["llm"]["generate_score"] = st.checkbox(
            "G√©n√©rer un score pour les offres et un commentaire (permet aussi de filtrer les offres 'score > 50')",
            config["llm"]["generate_score"])
        if config["llm"]["generate_score"]:
            config["llm"]["prompt_score"] = st.text_area("Adapter le prompt √† vos besoin sans changer la struture",
                                                         config["llm"]["prompt_score"])
        config["llm"]["generate_custom_profile"] = st.checkbox("G√©n√©rer un profile en fonction de l'offre",
                                                               config["llm"]["generate_custom_profile"])
        if config["llm"]["generate_custom_profile"]:
            config["llm"]["prompt_custom_profile"] = st.text_area("Entrez votre prompt pour g√©n√©rer votre profile",
                                                                  config["llm"]["prompt_custom_profile"])
            config["llm"]["cv"] = st.text_area("Le texte de votre CV afin de mieux adapter le r√©sum√© du profile",
                                               config["llm"]["cv"])

    col1, col2 = st.columns(2)

    with col1:
        if st.button("üíæ Sauvegarder la configuration"):
            save_config(config)
            st.success("Configuration sauvegard√©e avec succ√®s !")

    with col2:
        if st.button("‚ôªÔ∏è R√©initialiser la configuration"):
            if reset_config():
                st.success("Configuration r√©initialis√©e depuis config_default.json.")
                st.experimental_rerun()  # Recharge la page avec les nouvelles valeurs
            else:
                st.error("Fichier config_default.json introuvable.")

def scrapping_page():
    st.title("üîç Scraping d'offres d‚Äôemploi")

    # Initialisation des √©tats persistants
    if "scraping_running" not in st.session_state:
        st.session_state.scraping_running = False
    if "launch_clicked" not in st.session_state:
        st.session_state.launch_clicked = False
    if "scraping_started" not in st.session_state:
        st.session_state.scraping_started = False
    if "progress_dict" not in st.session_state:
        st.session_state.progress_dict = {
            "WelcomeToTheJungle": (0, 1),
            "Linkedin": (0, 1),
            "Apec": (0, 1),
            "Traitement des nouvelles offres (LLM)": (0, 1),
        }
    if "progress_bars" not in st.session_state:
        st.session_state.progress_bars = {}

    # Conteneur principal pour garder l‚Äôordre stable
    with st.container():
        # Bouton de lancement (avec protection double-clic)
        if st.button("üöÄ Lancer le scraping", disabled=st.session_state.scraping_running):
            if not st.session_state.launch_clicked:
                st.session_state.launch_clicked = True
                st.session_state.scraping_running = True
                st.rerun()

        # Affichage (ou re-cr√©ation) des barres de progression
        for platform, (current, total) in st.session_state.progress_dict.items():
            percent = int((current / total) * 100) if total > 0 else 0
            if platform not in st.session_state.progress_bars or st.session_state.progress_bars[platform] is None:
                st.session_state.progress_bars[platform] = st.progress(percent, text=f"{platform} : {current} offres ({percent}%)")
            else:
                st.session_state.progress_bars[platform].progress(
                    percent,
                    text=f"{platform} : {current} offres ({percent}%)"
                )

    # D√©marrage r√©el du scraping
    if st.session_state.scraping_running and not st.session_state.scraping_started:
        st.session_state.scraping_started = True  # √âvite plusieurs lancements

        # R√©initialise les barres et compteurs
        for k in st.session_state.progress_dict:
            st.session_state.progress_dict[k] = (0, 1)

        for k in st.session_state.progress_bars:
            st.session_state.progress_bars[k].progress(0, text=f"{k} (0 offres - 0%)")

        def run(progress_dict):
            success = update_store_data(progress_dict)
            result_container["success"] = success

        progress_dict = st.session_state.progress_dict
        result_container = {}
        thread = threading.Thread(target=run, args=(progress_dict,))
        thread.start()

        # Boucle de suivi des barres
        while thread.is_alive():
            for platform in st.session_state.progress_dict:
                current, total = st.session_state.progress_dict[platform]
                percent = int((current / total) * 100) if total > 0 else 0

                # Recr√©e si besoin (protection post-navigation)
                if platform not in st.session_state.progress_bars or st.session_state.progress_bars[platform] is None:
                    st.session_state.progress_bars[platform] = st.progress(percent, text=f"{platform} : {current} offres ({percent}%)")
                else:
                    st.session_state.progress_bars[platform].progress(
                        percent,
                        text=f"{platform} : {current} offres ({percent}%)"
                    )
            time.sleep(0.2)

        # Affiche le message en fonction du r√©sultat
        if result_container.get("success"):
            st.success("üéâ Scraping termin√© avec succ√®s !")
        else:
            st.error("‚ùå Une erreur est survenue pendant le scraping.")

        # R√©initialisation des √©tats
        st.session_state.scraping_running = False
        st.session_state.launch_clicked = False
        st.session_state.scraping_started = False

    configuration_page()




def new_offer_page(df):
    # Filtrer les offres non lues
    unread_jobs = df[(df["is_read"] == 0) & (df["is_good_offer"] == 1)] \
        .sort_values(by=["days_diff", "score"], ascending=[True, False]) \
        .reset_index(drop=True)

    total_jobs = len(unread_jobs)

    if unread_jobs.empty:
        st.title(f"üìå Offres d'emploi")
        st.write("‚úÖ Toutes les offres ont √©t√© lues !")
    else:
        st.title(f"üìå Offres d'emploi **{st.session_state.index + 1} / {total_jobs}**")
        current_index = st.session_state.index % total_jobs
        job = unread_jobs.iloc[current_index]

        st.subheader(job["title"])
        st.subheader(job["company"])
        st.markdown(f"[üîó Lien vers l'offre]({job['link']})", unsafe_allow_html=True)
        st.write(
            f"Publi√© il y a **{int(job['days_diff'])}** jours"
            if pd.notna(job['days_diff'])
            else "Date de publication non renseign√©e"
        )
        score = int(job["score"])
        if score != -1:
            color = get_color(score)
            st.markdown(f"""
               <div style="margin: 20px 0; width: 60%; background-color: #eee; border-radius: 5px;">
                 <div style="width: {score}%; background-color: {color}; padding: 10px 0; border-radius: 5px; text-align: center; color: white; font-weight: bold;">
                   {score}%
                 </div>
               </div>
               """, unsafe_allow_html=True)
        with st.expander("üí¨ Commentaire"):
            st.write(job["comment"])
        with st.expander("Proposition de description de profile"):
            st.write(job["custom_profile"])
        # st.write(job["content"])
        # st.code(job["content"])
        st.markdown(job["content"].replace("\n", "<br>"), unsafe_allow_html=True)

        col1, col2, col3 = st.columns(3)

        with col1:
            if st.button("‚¨ÖÔ∏è Pr√©c√©dent"):
                st.session_state.index = (st.session_state.index - 1) % total_jobs
                st.rerun()

        with col2:
            if st.button("Marquer comme lu ‚úÖ"):
                df.loc[df["link"] == job["link"], "is_read"] = 1
                save_data(df)
                st.rerun()

        with col3:
            if st.button("‚û°Ô∏è Suivant"):
                st.session_state.index = (st.session_state.index + 1) % total_jobs
                st.rerun()

        if st.button("üìé Postuler"):
            df.loc[df["link"] == job["link"], ["is_apply", "is_read"]] = 1
            save_data(df)
            st.rerun()

def offer_gpt_filter_page(df):
    st.title("üìÑ Offres non pertinentes")

    applied_jobs = df[(df["is_read"] == 0) & (df["is_good_offer"] == 0)] \
        .sort_values(by=["days_diff", "score"], ascending=[True, False]) \
        .reset_index(drop=True)

    if applied_jobs.empty:
        st.write("‚ùå Aucune offre filtr√©e")
    else:
        for index, job in applied_jobs.iterrows():
            col1, col2 = st.columns([0.85, 0.15])

            with col1:
                score = int(job["score"])
                color = get_color(score)
                st.markdown(f"""
                    <div style="margin: 20px 0; width: 100%; background-color: #eee; border-radius: 5px;">
                      <div style="width: {score}%; background-color: {color}; padding: 10px 0; border-radius: 5px; text-align: center; color: white; font-weight: bold;">
                        {score}%
                      </div>
                    </div>
                    """, unsafe_allow_html=True)
                st.write(
                    f"Publi√© il y a **{int(job['days_diff'])}** jours"
                    if pd.notna(job['days_diff'])
                    else "Date de publication non renseign√©e"
                )
                with st.expander(job["title"] + " | " + job["company"] + "\n" + job["comment"]):
                    st.write(job["content"])
                    st.markdown(f"[üîó Lien vers l'offre]({job['link']})", unsafe_allow_html=True)

            with col2:
                # Bouton pour r√©tablir l'offre
                st.markdown("<div style='height: 85px;'></div>", unsafe_allow_html=True)
                if st.button("üîÑ Restaurer", key=f"restore_{index}"):
                    df.loc[df["link"] == job["link"], "is_good_offer"] = 1
                    save_data(df)
                    st.rerun()

def offer_readed_page(df):
    st.title("üìÑ Offres d√©j√† lu et non postul√©")

    applied_jobs = df[(df["is_read"] == 1) & (df["is_apply"] == 0)].reset_index(drop=True)

    if applied_jobs.empty:
        st.write("‚ùå Aucun poste n'a √©t√© lu.")
    else:
        for index, job in applied_jobs.iterrows():
            col1, col2 = st.columns([0.9, 0.1])

            with col1:
                with st.expander(job["title"] + " | " + job["company"]):
                    st.write(job["content"])
                    st.markdown(f"[üîó Lien vers l'offre]({job['link']})", unsafe_allow_html=True)

            with col2:
                # Bouton de suppression √† droite
                if st.button("üóëÔ∏è", key=f"delete_{index}"):
                    df.loc[df["link"] == job["link"], ["is_apply", "is_read"]] = 0
                    save_data(df)
                    st.rerun()

def offer_refused_page(df):
    st.title("üö´ Candidatures refus√©es")

    refused_jobs = df[df["is_refused"] == 1].reset_index(drop=True)

    if refused_jobs.empty:
        st.write("‚úÖ Aucun poste n'a √©t√© marqu√© comme refus√©.")
    else:
        for index, job in refused_jobs.iterrows():
            col1, col2 = st.columns([0.9, 0.2])

            with col1:
                with st.expander(job["title"] + " | " + job["company"]):
                    st.write(job["content"])
                    st.markdown(f"[üîó Lien vers l'offre]({job['link']})", unsafe_allow_html=True)

            with col2:
                # Bouton pour r√©tablir l'offre et enlever le statut "refus√©"
                if st.button("üîÑ Restaurer", key=f"restore_{index}"):
                    df.loc[df["link"] == job["link"], "is_refused"] = 0
                    save_data(df)
                    st.rerun()



def offer_applied_page(df):
    st.title("üìÑ Candidatures en cours")

    applied_jobs = df[(df["is_apply"] == 1) & (df["is_refused"] == 0)].reset_index(drop=True)

    if applied_jobs.empty:
        st.write("‚ùå Aucune candidature en cours.")
    else:
        for index, job in applied_jobs.iterrows():
            col1, col2, col3 = st.columns([0.8, 0.1, 0.2])

            with col1:
                with st.expander(job["title"] + " | " + job["company"]):
                    st.write(job["content"])
                    st.markdown(f"[üîó Lien vers l'offre]({job['link']})", unsafe_allow_html=True)

            with col2:
                # Bouton de suppression √† droite
                if st.button("üóëÔ∏è", key=f"delete_{index}"):
                    df.loc[df["link"] == job["link"], ["is_apply", "is_read"]] = 0
                    save_data(df)
                    st.rerun()

            with col3:
                # Bouton pour marquer l'offre comme refus√©e
                if st.button("‚ùå Refus√©", key=f"refused_{index}"):
                    df.loc[df["link"] == job["link"], "is_refused"] = 1
                    save_data(df)
                    st.rerun()